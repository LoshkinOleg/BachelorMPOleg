class SteamAudio_AudioRenderer;

	enum class ClipWrapMode // Oleg@self: move somewhere common for all audio renderer implementations
	{
		ONE_SHOT,
		LOOP
	};

	class SteamAudio_SoundMaker
	{
	public:
		SteamAudio_SoundMaker() = default;
		SteamAudio_SoundMaker(const SteamAudio_SoundMaker&) = delete; // Owns a resource it's responsible for, so no copying.
		SteamAudio_SoundMaker(SteamAudio_SoundMaker&&) = default; // There's no reason for moving this class around.
		SteamAudio_SoundMaker& operator=(const SteamAudio_SoundMaker&) = delete; // Owns a resource it's responsible for, so no copy assignement.
		SteamAudio_SoundMaker& operator=(SteamAudio_SoundMaker&&) = default; // There's no need for move assignment for this class.

		// Oleg@self: those really should be replaced with constructors / destructors.
		bool Init(PaStreamCallback* serviceAudioCallback, bs::SteamAudio_AudioRenderer* engine, const char* wavFileName, const ClipWrapMode wrapMode = ClipWrapMode::ONE_SHOT);
		void Shutdown();

		void SetPosition(const float globalX, const float globalY, const float globalZ);

		// Oleg@self: maybe make a singleton out of this class instead of passing references of it in every method?...
		void ProcessAudio(std::vector<float>& outBuff, SteamAudio_AudioRenderer& engine);
		void Reset(SteamAudio_AudioRenderer& engine);

		inline PaStream* const GetStream() const { return pStream_; };
		inline ClipWrapMode GetWrapMode() const { return wrapMode_; };
		inline PaError const GetError() const { return err_; };
		inline uint32_t const GetCurrentBegin() const { return currentBegin_; };
		inline uint32_t const GetCurrentEnd() const { return currentEnd_; };
		inline const std::vector<float> GetSoundData() const { return soundData_; }; // Oleg@self: is this method useful?...
		
	private:

		// portaudio stuff
		PaStream* pStream_ = nullptr; // portaudio stream to playback device
		PaError err_;

		// SoundMaker specific stuff
		std::vector<float> soundData_; // Very large, contains whole wav file.
		uint32_t currentBegin_ = 0;
		uint32_t currentEnd_ = 0;
		ClipWrapMode wrapMode_ = ClipWrapMode::ONE_SHOT;
	};

bool bs::SteamAudio_SoundMaker::Init(PaStreamCallback* serviceAudioCallback, bs::SteamAudio_AudioRenderer* engine, const char* wavFileName, const ClipWrapMode wrapMode)
{
	currentBegin_ = 0;
	currentEnd_ = 0;
	wrapMode_ = wrapMode;

	soundData_ = LoadWav(wavFileName, 1, engine->GetSampleRate());

	PaStreamParameters outputParams{
		Pa_GetDefaultOutputDevice(), // Oleg@self: handle this properly.
		2,
		paFloat32, // Oleg@self: check this properly!
		0.050, // Oleg@self: magic number. Investigate.
		NULL
	};

	err_ = Pa_OpenStream(
		&pStream_,
		NULL,
		&outputParams,
		(double)SteamAudio_AudioRenderer::GetSampleRate(),
		(unsigned long)SteamAudio_AudioRenderer::GetBufferSize(),
		paClipOff, // Oleg@self: investigate
		serviceAudioCallback,
		engine
	);

	if (err_ != paNoError) {
		std::cerr << "Error opening stream: " << Pa_GetErrorText(err_) << std::endl;
		return false;
	}

	err_ = Pa_StartStream(pStream_); // Oleg@self: I think this should be part of Renderer instead.
	assert(!err_, "Sound maker reported error starting a stream.");

	return true;
}
void bs::SteamAudio_SoundMaker::Shutdown()
{
	err_ = Pa_StopStream(pStream_);
	assert(!err_, "Sound maker reported error stopping a stream.");
	err_ = Pa_CloseStream(pStream_);
	assert(!err_, "Sound maker reported error closing a stream.");
}
void bs::SteamAudio_SoundMaker::SetPosition(float globalX, float globalY, float globalZ)
{
	assert(false, "SetPosition() isn't implemented!");
}

void bs::SteamAudio_SoundMaker::ProcessAudio(std::vector<float>& outBuff, SteamAudio_AudioRenderer& engine)
{
	const auto bufferSize = engine.GetBufferSize();
	const auto wavSize = soundData_.size();
	static std::vector<float> frame(bufferSize);

	// Fill all buffers with silence.
	std::fill(frame.begin(), frame.end(), 0.0f);
	std::fill(outBuff.begin(), outBuff.end(), 0.0f);

	// Oleg@self: fix this fuckery, I'm getting confused by the indices / frame sizes, sample rates, etc...

	// Advance frame indices.
	currentBegin_ = currentEnd_ + 1;
	if (wrapMode_ == ClipWrapMode::ONE_SHOT)
	{
		if (currentBegin_ < wavSize) // Not overruning wav data.
		{
			currentEnd_ = currentBegin_ + engine.GetBufferSize() - 1;
		}
		else
		{
			currentEnd_ = wavSize - 1;
		}
	}
	else
	{
		if (currentBegin_ + engine.GetBufferSize() - 1 > wavSize) currentBegin_ = 0;
		currentEnd_ = currentBegin_ + engine.GetBufferSize() - 1;
	}

	// Load subset of audio data into frame.
	for (size_t i = 0; i < bufferSize; i++)
	{
		// Oleg@self: use memcpy?
		if ((currentBegin_ + i) < wavSize) // If we're not overruning the clip data, copy data.
		{
			frame[i] = soundData_[currentBegin_ + i];
		}
	}

	// Manually interleave.
	for (size_t i = 0; i < bufferSize; i++)
	{
		outBuff[2 * i] = frame[i];
		outBuff[2 * i + 1] = frame[i];
	}
}

void bs::SteamAudio_SoundMaker::Reset(SteamAudio_AudioRenderer& renderer)
{
	currentBegin_ = 0;
	currentEnd_ = 0;
}

using SoundMakerId = size_t; // Oleg@self: move to common file
	constexpr const size_t INVALID_ID = (size_t)-1;

	class SteamAudio_AudioRenderer
	{
	public:
		// Oleg@self: replace with constructor / destructor
		bool Init(size_t BUFFER_SIZE = 1024, size_t SAMPLE_RATE = 44100);
		void Shutdown();

		SoundMakerId CreateSoundMaker(const char* wavFileName, const ClipWrapMode wrapMode = ClipWrapMode::ONE_SHOT);
		void MoveSoundMaker(SoundMakerId id, const float globalX, const float globalY, const float globalZ);
		void ResetSoundMaker(SoundMakerId id);

		static size_t GetBufferSize() { return BUFFER_SIZE_; };
		static size_t GetSampleRate() { return SAMPLE_RATE_; };

	private:
		static int ServiceAudio_
		(
			const void* unused, void* outputBuffer,
			unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo* timeInfo,
			PaStreamCallbackFlags statusFlags, void* userData
		);

		// Renderer specific stuff
		std::vector<SteamAudio_SoundMaker> sounds_;

		static size_t BUFFER_SIZE_;
		static size_t SAMPLE_RATE_;
	};

size_t bs::SteamAudio_AudioRenderer::BUFFER_SIZE_ = 0;
size_t bs::SteamAudio_AudioRenderer::SAMPLE_RATE_ = 0;

bool bs::SteamAudio_AudioRenderer::Init(size_t BUFFER_SIZE, size_t SAMPLE_RATE)
{
	BUFFER_SIZE_ = BUFFER_SIZE;
	SAMPLE_RATE_ = SAMPLE_RATE;

	// Init portaudio.
	auto err = Pa_Initialize();
	if (err != paNoError) throw;

#ifdef USE_EASY_PROFILER
	// Enable writing a profiling file by easy_profiler.
	EASY_PROFILER_ENABLE;
#endif //! USE_EASY_PROFILER

	return true; // Oleg@self: use int instead. Most libs use int as return val and this would allow to have a single local result var to check for errors of all libs.
}
void bs::SteamAudio_AudioRenderer::Shutdown()
{
#ifdef USE_EASY_PROFILER
	// Oleg@self: parse directors and look how to name the next file without overwriting the existing one.
	// Write profiling data to file.
	const auto result = profiler::dumpBlocksToFile("profilingData/profilingData0.prof");
	assert(result, "Couldn't write .prof file!");
#endif //! USE_EASY_PROFILER

	for (auto& sound : sounds_)
	{
		sound.Shutdown();
	}
}

bs::SoundMakerId bs::SteamAudio_AudioRenderer::CreateSoundMaker(const char* wavFileName, const ClipWrapMode wrapMode)
{
	sounds_.emplace_back(SteamAudio_SoundMaker());
	if (!sounds_.back().Init(&ServiceAudio_, this, wavFileName, wrapMode))
	{
		assert(false, "Problem initializing the new SoundMaker!");
		sounds_.pop_back();
		return INVALID_ID;
	}
	return sounds_.size() - 1;
}

void bs::SteamAudio_AudioRenderer::MoveSoundMaker(bs::SoundMakerId id, float globalX, float globalY, float globalZ)
{
	assert(id != (size_t)-1, "Invalid sound maker id recieved in MoveSoundMaker()!");
	sounds_[id].SetPosition(globalX, globalY, globalZ);
}

void bs::SteamAudio_AudioRenderer::ResetSoundMaker(SoundMakerId id)
{
	/*
		WARNING: calling this function seems to do some wierd shit... Some data used for reverb processing gets invalidated?...
	*/
	sounds_[id].Reset(*this);
}

int bs::SteamAudio_AudioRenderer::ServiceAudio_
(
	const void* unused, void* outputBuffer,
	unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo* timeInfo,
	PaStreamCallbackFlags statusFlags, void* userData
)
{
	auto* engine = (SteamAudio_AudioRenderer*)userData; // Annoying hack to have a non static servicing method.
	if (engine->sounds_.size() <= 0) return paContinue;
	auto* sound = dynamic_cast<SteamAudio_SoundMaker*>(&engine->sounds_[0]);
	static std::vector<float> processedFrame(BUFFER_SIZE_ * 2);
	auto* outBuff = static_cast<float*>(outputBuffer); // Cast output buffer to float buffer.

	sound->ProcessAudio(processedFrame, *engine); // Oleg@self: make a virtual method out of this.

	// Oleg@self: use memcpy?
	for (auto it = processedFrame.begin(); it != processedFrame.end(); it++)
	{
		*(outBuff++) = *it;
	}

	return paContinue;
}

static void Update(bs::SteamAudio_AudioRenderer& audioRenderer, bs::SoundMakerId soundId)
{
	static size_t currentPosition = 0;
	constexpr const size_t NR_OF_POSITIONS = 6;
	constexpr const std::array<std::array<float, 3>, NR_OF_POSITIONS> positions =
	{{
		{1.0f, 0.0f, 0.0f}, /* Oleg@self: move all this to a json file or something */
		{-1.0f, 0.0f, 0.0f},

		{0.0f, 1.0f, 0.0f},
		{0.0f, -1.0f, 0.0f},

		{0.0f, 0.0f, 1.0f},
		{0.0f, 0.0f, -1.0f}
	}};

	if (++currentPosition >= NR_OF_POSITIONS) currentPosition = 0;

	audioRenderer.MoveSoundMaker(soundId, positions[currentPosition][0], positions[currentPosition][1], positions[currentPosition][2]);
}

static int RunProgram()
{
	{// Scoped sucess check.
		auto result = SDL_Init(SDL_INIT_EVERYTHING);
		assert(result == 0, "SDL failed to initialize!");
	}

	auto* window = SDL_CreateWindow("ProfilingApp", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 720, 720, 0);
	assert(window, "SDL failed to create a window!");

	bs::SteamAudio_AudioRenderer audioRenderer;
	{// Scoped success chack.
		auto initSuccess = audioRenderer.Init(2048);
		assert(initSuccess, "Failed to initialize audio renderer!");
	}
	auto sound = audioRenderer.CreateSoundMaker("../resources/AudioSamples/brownNoise_44100Hz_32f_5sec.wav", bs::ClipWrapMode::LOOP);
	assert(sound != bs::INVALID_ID, "Failed to load wav file!");

	bool shutdown = false;
	while (!shutdown)
	{
		SDL_Event e;
		while (SDL_PollEvent(&e))
		{
			switch (e.type)
			{
				case SDL_QUIT:
				{
					shutdown = true;

				}break;

				case SDL_KEYDOWN:
				{
					switch (e.key.keysym.scancode)
					{
						case SDL_SCANCODE_ESCAPE:
						{
							shutdown = true;
						}break;

						case SDL_SCANCODE_SPACE:
						{
							Update(audioRenderer, sound); // Update audio renderer
						}break;
					default:break;}
				}break;
			default:break;}
		}
	}
	audioRenderer.Shutdown();
	SDL_Quit();

	return 0;
}